{"ast":null,"code":"// src/utils/editor-integration.js\nconst RAW_API_BASE = process.env.REACT_APP_API_BASE || \"http://localhost:3001\";\n\n/**\n * Normalizes base + path into a single URL string.\n * Ensures there is exactly one slash between base and path.\n */\nfunction joinUrl(base, path) {\n  if (!base) return path;\n  if (!path) return base;\n  const trimmedBase = base.replace(/\\/+$/, '');\n  const trimmedPath = path.replace(/^\\/+/, '');\n  return `${trimmedBase}/${trimmedPath}`;\n}\n\n/**\n * Low-level request helper\n * opts:\n *  - method, headers, body, signal, timeout (ms), rawResponse (bool)\n *  - authToken (string) - if provided, attaches Authorization: Bearer <token>\n */\nasync function request(path, opts = {}) {\n  const {\n    timeout = 15000,\n    rawResponse = false,\n    authToken,\n    ...fetchOpts\n  } = opts;\n  const url = joinUrl(RAW_API_BASE, path);\n  const controller = new AbortController();\n  const timeoutId = timeout ? setTimeout(() => controller.abort(), timeout) : null;\n  // merge signals (if caller supplied signal, we should respect it too)\n  if (fetchOpts.signal) {\n    // If caller passed a signal, we will abort if either the caller aborts or our timeout hits.\n    // Create a small helper: if caller aborts, also abort controller.\n    const callerSignal = fetchOpts.signal;\n    if (callerSignal.aborted) controller.abort();\n    const onAbort = () => controller.abort();\n    callerSignal.addEventListener('abort', onAbort);\n    // ensure we remove the listener later\n    fetchOpts._callerAbortListener = onAbort;\n  }\n\n  // Headers: ensure object, allow caller to pass headers\n  fetchOpts.headers = Object.assign({}, fetchOpts.headers || {});\n  if (authToken) fetchOpts.headers['Authorization'] = `Bearer ${authToken}`;\n\n  // Attach our controller's signal\n  fetchOpts.signal = controller.signal;\n  let res;\n  try {\n    res = await fetch(url, fetchOpts);\n  } catch (err) {\n    // normalize abort error for consumer\n    if (err.name === 'AbortError') {\n      throw new Error(`Request aborted (timeout ${timeout}ms or cancelled) for ${url}`);\n    }\n    console.warn('API request network error', err);\n    throw err;\n  } finally {\n    // cleanup timeout and any attached listener\n    if (timeoutId) clearTimeout(timeoutId);\n    if (fetchOpts._callerAbortListener && fetchOpts.signal && fetchOpts.signal.removeEventListener) {\n      try {\n        fetchOpts.signal.removeEventListener('abort', fetchOpts._callerAbortListener);\n      } catch (e) {/* ignore */}\n    }\n  }\n\n  // If response is not ok, capture body text (if available) to help debugging\n  if (!res.ok) {\n    let bodyText = null;\n    try {\n      bodyText = await res.text();\n    } catch (e) {\n      // ignore parse errors\n    }\n    const err = new Error(`HTTP ${res.status} ${res.statusText}${bodyText ? ` - ${bodyText}` : ''}`);\n    err.status = res.status;\n    err.body = bodyText;\n    err.response = res;\n    console.warn('API request returned error', err);\n    throw err;\n  }\n  if (rawResponse) return res;\n\n  // try parse JSON, but handle empty responses gracefully\n  const ct = res.headers.get('content-type') || '';\n  if (!ct.includes('application/json')) {\n    // not JSON — return text\n    const text = await res.text();\n    return text;\n  }\n\n  // JSON\n  try {\n    return await res.json();\n  } catch (e) {\n    // JSON parse failed — surface helpful error\n    const text = await res.text().catch(() => null);\n    const parseErr = new Error(`Failed to parse JSON response from ${url}${text ? ` — body: ${text}` : ''}`);\n    parseErr.response = res;\n    console.warn(parseErr);\n    throw parseErr;\n  }\n}\n\n/* Public helpers (maintain simple API) */\n\nexport async function fetchTemplate(name, opts = {}) {\n  if (!name) throw new Error('fetchTemplate: template name required');\n  // opts may include timeout, authToken, rawResponse etc.\n  return await request(`/api/templates/${encodeURIComponent(name)}`, {\n    method: 'GET',\n    ...opts\n  });\n}\nexport async function saveTemplate(name, json, opts = {}) {\n  if (!name) throw new Error('saveTemplate: template name required');\n  if (typeof json === 'undefined') throw new Error('saveTemplate: json payload required');\n  const headers = Object.assign({\n    'Content-Type': 'application/json'\n  }, opts.headers || {});\n  // large payloads: consider gzip compression on server; fetch will send as-is\n  return await request(`/api/templates/${encodeURIComponent(name)}`, {\n    method: 'PUT',\n    headers,\n    body: JSON.stringify(json),\n    ...opts\n  });\n}","map":{"version":3,"names":["RAW_API_BASE","process","env","REACT_APP_API_BASE","joinUrl","base","path","trimmedBase","replace","trimmedPath","request","opts","timeout","rawResponse","authToken","fetchOpts","url","controller","AbortController","timeoutId","setTimeout","abort","signal","callerSignal","aborted","onAbort","addEventListener","_callerAbortListener","headers","Object","assign","res","fetch","err","name","Error","console","warn","clearTimeout","removeEventListener","e","ok","bodyText","text","status","statusText","body","response","ct","get","includes","json","catch","parseErr","fetchTemplate","encodeURIComponent","method","saveTemplate","JSON","stringify"],"sources":["/Users/harleen/Documents/GameBuilderProject/frontend/src/utils/editor-integration.js"],"sourcesContent":["// src/utils/editor-integration.js\nconst RAW_API_BASE = process.env.REACT_APP_API_BASE || \"http://localhost:3001\";\n\n/**\n * Normalizes base + path into a single URL string.\n * Ensures there is exactly one slash between base and path.\n */\nfunction joinUrl(base, path) {\n  if (!base) return path;\n  if (!path) return base;\n  const trimmedBase = base.replace(/\\/+$/, '');\n  const trimmedPath = path.replace(/^\\/+/, '');\n  return `${trimmedBase}/${trimmedPath}`;\n}\n\n/**\n * Low-level request helper\n * opts:\n *  - method, headers, body, signal, timeout (ms), rawResponse (bool)\n *  - authToken (string) - if provided, attaches Authorization: Bearer <token>\n */\nasync function request(path, opts = {}) {\n  const {\n    timeout = 15000,\n    rawResponse = false,\n    authToken,\n    ...fetchOpts\n  } = opts;\n\n  const url = joinUrl(RAW_API_BASE, path);\n\n  const controller = new AbortController();\n  const timeoutId = timeout ? setTimeout(() => controller.abort(), timeout) : null;\n  // merge signals (if caller supplied signal, we should respect it too)\n  if (fetchOpts.signal) {\n    // If caller passed a signal, we will abort if either the caller aborts or our timeout hits.\n    // Create a small helper: if caller aborts, also abort controller.\n    const callerSignal = fetchOpts.signal;\n    if (callerSignal.aborted) controller.abort();\n    const onAbort = () => controller.abort();\n    callerSignal.addEventListener('abort', onAbort);\n    // ensure we remove the listener later\n    fetchOpts._callerAbortListener = onAbort;\n  }\n\n  // Headers: ensure object, allow caller to pass headers\n  fetchOpts.headers = Object.assign({}, fetchOpts.headers || {});\n  if (authToken) fetchOpts.headers['Authorization'] = `Bearer ${authToken}`;\n\n  // Attach our controller's signal\n  fetchOpts.signal = controller.signal;\n\n  let res;\n  try {\n    res = await fetch(url, fetchOpts);\n  } catch (err) {\n    // normalize abort error for consumer\n    if (err.name === 'AbortError') {\n      throw new Error(`Request aborted (timeout ${timeout}ms or cancelled) for ${url}`);\n    }\n    console.warn('API request network error', err);\n    throw err;\n  } finally {\n    // cleanup timeout and any attached listener\n    if (timeoutId) clearTimeout(timeoutId);\n    if (fetchOpts._callerAbortListener && fetchOpts.signal && fetchOpts.signal.removeEventListener) {\n      try { fetchOpts.signal.removeEventListener('abort', fetchOpts._callerAbortListener); } catch(e){ /* ignore */ }\n    }\n  }\n\n  // If response is not ok, capture body text (if available) to help debugging\n  if (!res.ok) {\n    let bodyText = null;\n    try {\n      bodyText = await res.text();\n    } catch (e) {\n      // ignore parse errors\n    }\n    const err = new Error(`HTTP ${res.status} ${res.statusText}${bodyText ? ` - ${bodyText}` : ''}`);\n    err.status = res.status;\n    err.body = bodyText;\n    err.response = res;\n    console.warn('API request returned error', err);\n    throw err;\n  }\n\n  if (rawResponse) return res;\n\n  // try parse JSON, but handle empty responses gracefully\n  const ct = res.headers.get('content-type') || '';\n  if (!ct.includes('application/json')) {\n    // not JSON — return text\n    const text = await res.text();\n    return text;\n  }\n\n  // JSON\n  try {\n    return await res.json();\n  } catch (e) {\n    // JSON parse failed — surface helpful error\n    const text = await res.text().catch(()=>null);\n    const parseErr = new Error(`Failed to parse JSON response from ${url}${text ? ` — body: ${text}` : ''}`);\n    parseErr.response = res;\n    console.warn(parseErr);\n    throw parseErr;\n  }\n}\n\n/* Public helpers (maintain simple API) */\n\nexport async function fetchTemplate(name, opts = {}) {\n  if (!name) throw new Error('fetchTemplate: template name required');\n  // opts may include timeout, authToken, rawResponse etc.\n  return await request(`/api/templates/${encodeURIComponent(name)}`, { method: 'GET', ...opts });\n}\n\nexport async function saveTemplate(name, json, opts = {}) {\n  if (!name) throw new Error('saveTemplate: template name required');\n  if (typeof json === 'undefined') throw new Error('saveTemplate: json payload required');\n\n  const headers = Object.assign({ 'Content-Type': 'application/json' }, opts.headers || {});\n  // large payloads: consider gzip compression on server; fetch will send as-is\n  return await request(`/api/templates/${encodeURIComponent(name)}`, {\n    method: 'PUT',\n    headers,\n    body: JSON.stringify(json),\n    ...opts\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}